\relax 
\abx@aux@refcontext{nty/global//global/global}
\@writefile{toc}{\boolfalse {citerequest}\boolfalse {citetracker}\boolfalse {pagetracker}\boolfalse {backtracker}\relax }
\@writefile{lof}{\boolfalse {citerequest}\boolfalse {citetracker}\boolfalse {pagetracker}\boolfalse {backtracker}\relax }
\@writefile{lot}{\boolfalse {citerequest}\boolfalse {citetracker}\boolfalse {pagetracker}\boolfalse {backtracker}\relax }
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {section}{\numberline {1}Hidden Surface Removal Problem:}{1}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Which algorithmic paradigm will you use to solve this problem?}{1}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Why did you chose the algorithmic paradigm selected above to solve this problem?}{1}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}Give an algorithm that takes $n$ lines as input, and in $O(n \qopname  \relax o{log}{n})$ time returns all of the lines that are visible. Provide a clear description of the algorithm.}{1}}
\@writefile{loa}{\defcounter {refsection}{0}\relax }\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces Hidden-Surface-Removal: HSR($L$)\relax }}{1}}
\abx@aux@cite{algDesign}
\abx@aux@segm{0}{0}{algDesign}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}Perform asymptotic analysis of your algorithm's running time. Also, consider the run time performance of a best case, worst case, and average case input model scenario.}{2}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {1.5}Provide a proof that your algorithm works correctly:}{2}}
\@writefile{lof}{\defcounter {refsection}{0}\relax }\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces $n=2$\relax }}{2}}
\@writefile{lof}{\defcounter {refsection}{0}\relax }\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces $n=3$, all lines visible\relax }}{2}}
\@writefile{lof}{\defcounter {refsection}{0}\relax }\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces $n=3$, two lines visible\relax }}{2}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{Merge}{{\caption@xref {Merge}{ on input line 158}}{3}}
\@writefile{lof}{\defcounter {refsection}{0}\relax }\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Set of Lines 1-5, where $m_1 < m_2 < m_3 <m_4 < m_5$\relax }}{3}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {section}{\numberline {2}Bipartite Matching Problem}{4}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Which algorithmic paradigm best describes this algorithm?}{4}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Why did you choose the algorithmic paradigm selected above?}{4}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Give an example of a bipartite graph $G$ for which this algorithm does not return the maximum matching.}{4}}
\newlabel{Bipartite}{{\caption@xref {Bipartite}{ on input line 189}}{4}}
\@writefile{lof}{\defcounter {refsection}{0}\relax }\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Graph $G$ where the middle edge was selected first\relax }}{4}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Let $M$ and $M'$ be matchings in a bipartite graph $G$. Suppose that $|M'| > 2 \cdot |M|.$ Show that there is an edge $e' \in M'$ such that $M \cup {e'}$ is a matching in $G$.}{4}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {2.5}Using the previous claim (and your supporting proof) to further prove that the algorithm is optimal or that the algorithm is $\rho $-optimal approximate (in this case be sure to derive the value of $\rho $ as part of your proof).}{4}}
\abx@aux@segm{0}{0}{algDesign}
\abx@aux@segm{0}{0}{algDesign}
\abx@aux@refcontextdefaultsdone
\abx@aux@defaultrefcontext{0}{algDesign}{nty/global//global/global}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {section}{\numberline {3}Number Partitioning Problem}{5}}
\@writefile{toc}{\defcounter {refsection}{0}\relax }\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Problem Statement:}{5}}
